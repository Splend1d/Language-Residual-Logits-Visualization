<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Multi-Model Residual/Logits Visualizer</title>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; }
  h1 { margin-bottom: 8px; }
  #audioIdButtons { margin: 8px 0 16px; }
  .audio-id-btn {
    margin: 3px 6px 10px 0;
    padding: 6px 12px;
    cursor: pointer;
    border-radius: 6px;
    border: 1.5px solid #4285f4;
    background: #fff;
    color: #4285f4;
    font-weight: 600;
    user-select: none;
  }
  .audio-id-btn.selected { background: #4285f4; color: #fff; }

  #sentence {
    margin: 10px 0 20px;
    font-size: 1.5rem;
    line-height: 1.8rem;
    word-wrap: break-word;
  }
  .word {
    cursor: pointer;
    padding: 3px 6px;
    border-radius: 4px;
    margin-right: 4px;
    user-select: none;
  }
  .word:hover { background: #eee; }
  .word.selected { background: #a0d3ff; }

  #panels {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 18px;
    align-items: start;
  }
  .panel {
    border: 1px solid #ddd;
    border-radius: 10px;
    padding: 12px;
    min-height: 160px;
  }
  .panel h3 { margin: 0 0 10px; color: #1a73e8; font-size: 1rem; }
  .candidate { margin: 2px 0; }
  .candidate-bar {
    display: inline-block;
    height: 14px;
    background: #4285f4; /* default blue; red when logscale */
    vertical-align: middle;
    min-width: 1px;
  }
  .candidate-text { margin-left: 6px; vertical-align: middle; }
  .no-data { font-style: italic; color: #888; }
  .muted { color: #666; font-size: 0.9rem; }
</style>
</head>
<body>

<h1>Language Residual / Logits Visualizer</h1>
<div class="muted">Auto-detects all <code>assets/*.jsonl</code> and compares them side-by-side.</div>

<div id="audioIdButtons"></div>

<div id="sentence">Loading model list…</div>

<div id="panels"></div>

<script>
// ---------- Configuration / discovery ----------
const REPO_GH_IO = /\.github\.io$/i.test(location.hostname);
const PATH_SEGMENTS = location.pathname.replace(/^\/+|\/+$/g,'').split('/');
const OWNER = REPO_GH_IO ? location.hostname.split('.')[0] : null;   // e.g., splend1d
const REPO  = REPO_GH_IO ? (PATH_SEGMENTS[0] || '') : '';            // e.g., Language-Residual-Logits-Visualization

// Set the JSONL whose order we follow
const ORDER_SOURCE = 'whisper-large-v3.jsonl';

// Manifest fallback for custom domains or API limits: assets/manifest.json -> ["file1.jsonl","file2.jsonl"]
async function listJsonlAssets() {
  if (OWNER && REPO) {
    try {
      const api = `https://api.github.com/repos/${OWNER}/${REPO}/contents/assets`;
      const r = await fetch(api);
      if (r.ok) {
        const arr = await r.json();
        const files = arr
          .filter(x => x.type === 'file' && /\.jsonl$/i.test(x.name))
          .map(x => x.name)
          .sort();
        if (files.length) return files;
      }
    } catch (e) {
      console.warn('GitHub API listing failed, will try manifest:', e);
    }
  }
  try {
    const m = await fetch('assets/manifest.json', { cache: 'no-store' });
    if (m.ok) {
      const files = await m.json();
      return (files || []).filter(n => /\.jsonl$/i.test(n)).sort();
    }
  } catch (e) {
    console.warn('Manifest not found or invalid:', e);
  }
  return [];
}

// ---------- Data structures ----------
/*
  modelsData = {
    "<modelName>": Map<audio_id, Array<entry>>
  }
  entry: { audio_id, target_id, target_text, candidates: {token: probOrLog, ...}, ... }
*/
const modelsData = {};
let modelOrder = []; // array of modelNames (from filenames sans .jsonl)
let allAudioIds = new Set();
// Preserve the appearance order of audio IDs from ORDER_SOURCE
const audioIdOrder = [];

// ---------- Load & parse ----------
async function loadAll() {
  const files = await listJsonlAssets();
  if (!files.length) {
    document.getElementById('sentence').textContent = 'No assets/*.jsonl files found.';
    return;
  }

  modelOrder = files.map(n => n.replace(/\.jsonl$/i, ''));

  // Small console check for logscale detection
  modelOrder.forEach(m => console.log(`[logscale?] ${m} ->`, /logscale/i.test(m)));

  const orderSourceLower = ORDER_SOURCE.toLowerCase();
  let sawOrderSource = false;

  for (let fi = 0; fi < files.length; fi++) {
    const file = files[fi];
    const modelName = file.replace(/\.jsonl$/i, '');
    modelsData[modelName] = new Map();

    const res = await fetch(`assets/${file}`, { cache: 'no-store' });
    if (!res.ok) {
      console.warn('Failed to fetch', file, res.status);
      continue;
    }
    const text = await res.text();
    const lines = text.split('\n').filter(l => l.trim());

    // Record order only if this file is ORDER_SOURCE
    const recordOrder = file.toLowerCase() === orderSourceLower;
    if (recordOrder) sawOrderSource = true;
    const seenInOrderSource = new Set();

    for (const line of lines) {
      try {
        const obj = JSON.parse(line);
        const id = obj.audio_id;

        if (!modelsData[modelName].has(id)) modelsData[modelName].set(id, []);
        modelsData[modelName].get(id).push(obj);
        allAudioIds.add(id);

        if (recordOrder && !seenInOrderSource.has(id)) {
          audioIdOrder.push(id);
          seenInOrderSource.add(id);
        }
      } catch (e) {
        console.warn(`Skipping invalid JSON in ${file}:`, line);
      }
    }
    // Ensure per-audio arrays are sorted by target_id
    for (const [aid, arr] of modelsData[modelName]) {
      arr.sort((a,b) => a.target_id - b.target_id);
    }
  }

  if (!allAudioIds.size) {
    document.getElementById('sentence').textContent = 'No valid JSONL entries found.';
    return;
  }

  const orderedIds = (sawOrderSource && audioIdOrder.length) ? audioIdOrder : [...allAudioIds];
  renderAudioIdButtons(orderedIds);
  renderForAudioId(orderedIds[0]); // Default to first
}

// ---------- UI rendering ----------
function renderAudioIdButtons(ids) {
  const box = document.getElementById('audioIdButtons');
  box.innerHTML = '';
  ids.forEach((id, idx) => {
    const btn = document.createElement('button');
    btn.className = 'audio-id-btn';
    btn.textContent = id;
    if (idx === 0) btn.classList.add('selected');
    btn.onclick = () => {
      document.querySelectorAll('.audio-id-btn').forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      renderForAudioId(id);
    };
    box.appendChild(btn);
  });
}

function renderForAudioId(audioId) {
  // Build union of target_ids across all models for this audio_id
  const targetIds = new Set();
  for (const model of modelOrder) {
    const arr = modelsData[model].get(audioId) || [];
    arr.forEach(e => targetIds.add(e.target_id));
  }
  const orderedTids = [...targetIds].sort((a,b)=>a-b);

  // Build a single sentence: prefer the first model that has the token at that position
  const sentenceDiv = document.getElementById('sentence');
  sentenceDiv.innerHTML = `<strong>Audio ID: ${audioId}</strong><br/>`;
  orderedTids.forEach(tid => {
    let entry = null;
    for (const model of modelOrder) {
      const arr = modelsData[model].get(audioId) || [];
      const found = arr.find(e => e.target_id === tid);
      if (found) { entry = found; break; }
    }
    if (!entry) return;
    const span = document.createElement('span');
    span.className = 'word';
    span.textContent = (entry.target_text || '') + ' ';
    span.title = `Click to compare candidates for "${(entry.target_text||'').trim()}"`;
    span.onclick = () => {
      document.querySelectorAll('#sentence .word').forEach(w => w.classList.remove('selected'));
      span.classList.add('selected');
      renderCandidatePanels(audioId, tid, (entry.target_text || '').trim());
    };
    sentenceDiv.appendChild(span);
  });

  // Clear panels until a word is clicked
  const panels = document.getElementById('panels');
  panels.innerHTML = '';
  modelOrder.forEach(model => {
    const p = document.createElement('div');
    p.className = 'panel';
    p.id = `panel-${cssSafe(model)}`;
    p.innerHTML = `<h3>${model}.jsonl</h3><div class="no-data">Click a word above to see candidates.</div>`;
    panels.appendChild(p);
  });
}

function renderCandidatePanels(audioId, targetId, wordText) {
  modelOrder.forEach(model => {
    const arr = modelsData[model].get(audioId) || [];
    const entry = arr.find(e => e.target_id === targetId);
    const panel = document.getElementById(`panel-${cssSafe(model)}`);
    panel.innerHTML = `<h3>${model}.jsonl — Candidates for word "<em>${escapeHtml(wordText)}</em>" (position ${targetId})</h3>`;

    if (!entry) {
      panel.innerHTML += `<div class="no-data">No data for this word.</div>`;
      return;
    }

    // Treat filenames like: phi4-... .logscale.jsonl as logscale
    const isLogScale = /logscale/i.test(model);

    // Build pairs:
    // - token: "NULL" if empty/whitespace token
    // - rawString: EXACT JSONL text value (no reformatting)
    // - barVal:   for logscale => 10^(value), else => value
    const pairs = Object.entries(entry.candidates || {}).map(([cand, val]) => {
      const token = (cand ?? '').trim() === '' ? 'NULL' : cand;
      const rawString = String(val);
      const numeric = Number(val);
      const barVal = isFinite(numeric)
        ? (isLogScale ? Math.pow(10, numeric) : numeric)
        : 0;
      return { token, rawString, barVal };
    });

    if (!pairs.length) {
      panel.innerHTML += `<div class="no-data">No candidate probabilities available.</div>`;
      return;
    }

    pairs.sort((a, b) => b.barVal - a.barVal);
    const maxBar = pairs[0].barVal || 1;

    pairs.forEach(({ token, rawString, barVal }) => {
      const row = document.createElement('div');
      row.className = 'candidate';

      const bar = document.createElement('span');
      bar.className = 'candidate-bar';
      bar.style.width = `${Math.max(1, (barVal / maxBar) * 240)}px`;
      if (isLogScale) bar.style.background = '#d93025'; // red when logscale
      row.appendChild(bar);

      const txt = document.createElement('span');
      txt.className = 'candidate-text';
      if (isLogScale) {
        // EXACT original number from JSONL (e.g., "-15.911656963198604")
        txt.textContent = `${token} : ${rawString}`;
      } else {
        const pct = isFinite(barVal) ? (barVal * 100).toFixed(2) : 'NaN';
        txt.textContent = `${token} : ${pct}%`;
      }
      row.appendChild(txt);

      panel.appendChild(row);
    });
  });
}

// ---------- utils ----------
function cssSafe(s) { return s.replace(/[^a-z0-9_-]/gi, '_'); }
function escapeHtml(s) { return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

// Go!
loadAll();
</script>

</body>
</html>
